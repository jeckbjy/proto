{"name":"Proto","tagline":"my lite proto","body":"# lite proto\r\n\r\nlite proto相对于protocal buffer而言是一种简单的消息通信协议,使用c#开发，并支持插件扩展,主要工作原理解析proto文件并调用不同语言的插件输出对应语言的代码\r\n\r\n- 支持单行注释，以#开始\r\n- 仅支持import，enum，struct三种结构，不支持嵌套定义\r\n- 支持的基础数据有bool，sint8，uint8，sint16，uint16，sint32,uint32,sint64,uint64,float32(float),float64(double)，struct和指针\r\n- 支持的容器vector，list,map,set\r\n- 底层序列化仅包含两种数据结构，变长uint64和struct，所有的基础类型都会转化成变长uint64进行传输 \r\n- 支持版本升级，支持废弃删除字段\r\n- 限制:所有enum中的field名字都不能重复，struct如果带有ID则必须唯一\r\n\r\n# example:\r\n<pre><code>\r\nfile:test1.proto\r\n\r\nenum MsgID\r\n{\r\n\tS2C_Login = 1,\r\n\tS2C_Logout,\r\n\t\r\n\tC2S_Login = 5,\r\n\tC2S_Logout,\r\n}\r\n\r\nfile:test.proto\r\n#this is a test proto\r\nimport \"test1.proto\"\r\n\r\nenum Mode\r\n{\r\n\tMODE_BUY = 1,\r\n\tMODE_SELL,\r\n}\r\n\r\nstruct PhoneNumber\r\n{\r\n\tstring number;\r\n\tint8 type;\r\n}\r\n\r\nstruct Person\r\n{\r\n\tstring name;\t# person's name\r\n\tint32  id;\r\n\tstring email;\r\n}\r\n\r\nstruct AddressBook\r\n{\r\n\tvector<Person> persons;\r\n}\r\n\r\n#this is message\r\nstruct LoginMsg = S2C_Login\r\n{\r\n\tAddressBook address;\r\n\tint8 \t\tidata = delete;\r\n\tuint8 \t\tudata = 10;\r\n\tvector<int> vdata;\r\n\tmap<int,string> mdata;\r\n}\r\n</code></pre>\r\n\r\n# 消息序列化与反序列化\r\n类似tlv编码格式，所有field均使用flag+value的形式进行编码，而对于value仅包含两种格式：变长uint64和legth+content的复杂数据类型\r\n\r\n- flag用一个uint8保存：struct中的每个field都会有一个唯一id，id使用增量的方式保存在tag中，所以通常情况下tag都为0或者是一个很小的值，为了压缩tag，则按如下编码flag\r\n\t- 最高位标识类型，0：变长uint64，1：len+content类型\r\n\t- 高2，3位标识tag，0-2直接保存,3则表示flag后紧跟tag剩余大小\r\n\t- 低5位数据信息，var编码，最高位标识为1标识结束，故0-15可直接表示，剩余数据：如果是基本类型则紧随，如何是复杂类型，则长度在indexs中存储\r\n\r\n- 基础格式编码转换\r\n\t- sint8先转成uint8去除符号再转成uint64\r\n\t- bool,uint8,uint16,uint32,uint64直接强转成uint64\r\n\t- sint16,sint32,sint64会使用zigzag编码转化成uint64\r\n\t- float32内存中强转成uint32,c中实现 union { float  f; uint32_t i; }\r\n\t- float64内存中强转成uint64,c中实现 union { double f; uint64_t i; }\r\n- string，blob等已知长度复杂类型：使用length+content编码\r\n- stl内部数据序列化：\r\n\t- 自身使用的length+content的形式\r\n\t- 内部序列化有两种方式,目前使用的方式1\r\n\t\t1. 和外部的field编码一样，tag使用0表示：缺点是会浪费3个无效bit，因为tag和类型是已知的,优点是无需另实现序列化函数\r\n\t\t2. 去除flag信息，无数据浪费，但缺点是需要重新写一套序列化函数\r\n- struct(内部struct)序列化：由于事先不知length故flag中不能容纳时需要放到索引区去获得大小\r\n- packet（顶层struct）序列化:head+body\r\n\t1. head:flag(3-3-2)+msg_len+idx_len+msgid,flag占用1个字节标识后边每个数据所占用字节数，msg_len,idx_len,msgid使用小端编码\r\n\t2. body:content+index，index由于序列化之前并不知道，故必须放到末尾\r\n\r\n# 开发计划\r\n\r\n为了压缩tag信息，目前编码方式是：flag中高位标识tag信息，低位标识data数据，这样导致了api在的复杂，在将来的开发中可能会改为tag和data完全分离，tag信息合并压缩","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}