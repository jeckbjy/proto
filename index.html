<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Proto by jeckbjy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Proto</h1>
      <h2 class="project-tagline">my lite proto</h2>
      <a href="https://github.com/jeckbjy/proto" class="btn">View on GitHub</a>
      <a href="https://github.com/jeckbjy/proto/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jeckbjy/proto/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="lite-proto" class="anchor" href="#lite-proto" aria-hidden="true"><span class="octicon octicon-link"></span></a>lite proto</h1>

<p>lite proto相对于protocal buffer而言是一种简单的消息通信协议,使用c#开发，并支持插件扩展,主要工作原理解析proto文件并调用不同语言的插件输出对应语言的代码</p>

<ul>
<li>支持单行注释，以#开始</li>
<li>仅支持import，enum，struct三种结构，不支持嵌套定义</li>
<li>支持的基础数据有bool，sint8，uint8，sint16，uint16，sint32,uint32,sint64,uint64,float32(float),float64(double)，struct和指针</li>
<li>支持的容器vector，list,map,set</li>
<li>底层序列化仅包含两种数据结构，变长uint64和struct，所有的基础类型都会转化成变长uint64进行传输 </li>
<li>支持版本升级，支持废弃删除字段</li>
<li>限制:所有enum中的field名字都不能重复，struct如果带有ID则必须唯一</li>
</ul>

<h1>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>example:</h1>

<pre><code>
file:test1.proto

enum MsgID
{
    S2C_Login = 1,
    S2C_Logout,
    
    C2S_Login = 5,
    C2S_Logout,
}

file:test.proto
#this is a test proto
import "test1.proto"

enum Mode
{
    MODE_BUY = 1,
    MODE_SELL,
}

struct PhoneNumber
{
    string number;
    int8 type;
}

struct Person
{
    string name;    # person's name
    int32  id;
    string email;
}

struct AddressBook
{
    vector persons;
}

#this is message
struct LoginMsg = S2C_Login
{
    AddressBook address;
    int8        idata = delete;
    uint8       udata = 10;
    vector vdata;
    map mdata;
}
</code></pre>

<h1>
<a id="消息序列化与反序列化" class="anchor" href="#%E6%B6%88%E6%81%AF%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息序列化与反序列化</h1>

<p>类似tlv编码格式，所有field均使用flag+value的形式进行编码，而对于value仅包含两种格式：变长uint64和legth+content的复杂数据类型</p>

<ul>
<li>
<p>flag用一个uint8保存：struct中的每个field都会有一个唯一id，id使用增量的方式保存在tag中，所以通常情况下tag都为0或者是一个很小的值，为了压缩tag，则按如下编码flag</p>

<ul>
<li>最高位标识类型，0：变长uint64，1：len+content类型</li>
<li>高2，3位标识tag，0-2直接保存,3则表示flag后紧跟tag剩余大小</li>
<li>低5位数据信息，var编码，最高位标识为1标识结束，故0-15可直接表示，剩余数据：如果是基本类型则紧随，如何是复杂类型，则长度在indexs中存储</li>
</ul>
</li>
<li>
<p>基础格式编码转换</p>

<ul>
<li>sint8先转成uint8去除符号再转成uint64</li>
<li>bool,uint8,uint16,uint32,uint64直接强转成uint64</li>
<li>sint16,sint32,sint64会使用zigzag编码转化成uint64</li>
<li>float32内存中强转成uint32,c中实现 union { float  f; uint32_t i; }</li>
<li>float64内存中强转成uint64,c中实现 union { double f; uint64_t i; }</li>
</ul>
</li>
<li>string，blob等已知长度复杂类型：使用length+content编码</li>
<li>stl内部数据序列化：

<ul>
<li>自身使用的length+content的形式</li>
<li>内部序列化有两种方式,目前使用的方式1

<ol>
<li>和外部的field编码一样，tag使用0表示：缺点是会浪费3个无效bit，因为tag和类型是已知的,优点是无需另实现序列化函数</li>
<li>去除flag信息，无数据浪费，但缺点是需要重新写一套序列化函数</li>
</ol>
</li>
</ul>
</li>
<li>struct(内部struct)序列化：由于事先不知length故flag中不能容纳时需要放到索引区去获得大小</li>
<li>packet（顶层struct）序列化:head+body

<ol>
<li>head:flag(3-3-2)+msg_len+idx_len+msgid,flag占用1个字节标识后边每个数据所占用字节数，msg_len,idx_len,msgid使用小端编码</li>
<li>body:content+index，index由于序列化之前并不知道，故必须放到末尾</li>
</ol>
</li>
</ul>

<h1>
<a id="开发计划" class="anchor" href="#%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发计划</h1>

<p>为了压缩tag信息，目前编码方式是：flag中高位标识tag信息，低位标识data数据，这样导致了api在的复杂，在将来的开发中可能会改为tag和data完全分离，tag信息合并压缩</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jeckbjy/proto">Proto</a> is maintained by <a href="https://github.com/jeckbjy">jeckbjy</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
